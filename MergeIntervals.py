# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NMf7HLOAZzdO6j7UwFMV8puIn3Kh69ix
"""

'''Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Input: intervals = [[1,3],[2,6],[8,10],[15,18]]

'''

intervals = [[1,3],[2,6],[15,18],[8,10]]
#sort the list of lists
#intervals.sort(key = lambda i: i[0])
intervals.sort()

#set the starting list to output. 
output = [intervals[0]]

#loop through all lists from intervals starting from 1.. because intervals[0] is already in output
for s,e in intervals[1:]:
  #set the end value of last list in output
  prevEnd = output[-1][1]
  #if starting element is less than the prevEnd --> there is overlap
  if s <= prevEnd:
    #why max? because end value of last list in output can be greater than end value of the current list
    output[-1][1] = max(prevEnd,e)
  #if there is no overlap, append to the output
  else:
    output.append([s,e])

print(output)